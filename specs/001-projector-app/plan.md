# Implementation Plan: Projector App (Broadcast Display Client)

**Branch**: `001-projector-app` | **Date**: 2025-11-04 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-projector-app/spec.md`

## Summary

The projector-app is a read-only broadcast client built with React + TypeScript + Vite that displays game state reactively for a wedding quiz game event. It consumes three real-time data sources: (1) Firestore `gameState/live` document for primary state, (2) WebSocket connection to socket-server for synchronized events (gong sound triggers), and (3) dynamic Firestore listeners on `questions/{questionId}/answers` for live answer counts. The app manages all event audio (BGM loops and one-shot sound effects) from Firebase Storage, handles 8 game phases with distinct UI screens, and requires no authentication. Target performance: <500ms state update latency, <100ms audio playback latency, 4+ hours stable uptime.

## Technical Context

**Language/Version**: TypeScript 5.3+ with React 18.2+
**Primary Dependencies**: React 18.2, Vite 5.0, Firebase SDK 10.x (Firestore + Storage), socket.io-client 4.x, Web Audio API
**Storage**: Firebase Firestore (read-only listeners), Firebase Storage (audio asset hosting)
**Testing**: Vitest (unit), React Testing Library (component), Playwright (E2E)
**Target Platform**: Modern browsers (Chrome 90+, Firefox 88+, Safari 14+) on large displays (projectors, monitors)
**Project Type**: Frontend web application (part of monorepo at `/apps/projector-app`)
**Performance Goals**: <500ms Firestore state updates, <100ms audio playback latency, <50ms WebSocket synchronization
**Constraints**: Read-only client (no writes to Firestore/API), must handle mid-game cold starts, no offline mode
**Scale/Scope**: Single projector instance per event, 8 game phase screens, ~10-15 audio assets, listens to 1 Firestore doc + dynamic answer collections

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Monorepo Architecture
✅ **PASS** - projector-app will be located at `/apps/projector-app` per constitution
✅ **PASS** - Will consume shared types from `/packages/types` (GameState, Question, Answer, GameResults)
✅ **PASS** - No cross-app boundaries violated (read-only client, no direct database access)
✅ **PASS** - Will have own package.json with explicit dependencies
✅ **PASS** - Does not write to Firestore (read-only broadcast client)

### II. Test-Driven Development (TDD)
✅ **PASS** - All implementation will follow Red-Green-Refactor cycle
✅ **PASS** - Tests will be written before implementation code
✅ **PASS** - Unit tests for hooks, components; integration tests for Firestore/WebSocket; E2E for phase transitions

### III. OpenAPI-First API Design
✅ **N/A** - projector-app does not expose REST APIs (frontend-only)
✅ **N/A** - Consumes WebSocket events from socket-server (not REST)
⚠️ **NOTE** - Will rely on existing api-server OpenAPI contracts for type definitions (indirect dependency)

### IV. Code Quality Gates
✅ **PASS** - ESLint + Prettier will be configured for React/TypeScript
✅ **PASS** - All tests must pass before commits
✅ **PASS** - Verification steps will be documented for each phase transition

### V. Shell Command Safety
✅ **PASS** - Vite commands will use appropriate timeouts
✅ **PASS** - No interactive commands in automation
✅ **PASS** - CI/CD will enforce timeout policies

**Gate Result**: ✅ ALL PASS - Proceed to Phase 0 research

## Project Structure

### Documentation (this feature)

```text
specs/001-projector-app/
├── spec.md                    # Feature specification (completed)
├── plan.md                    # This file (current)
├── research.md                # Phase 0 output (to be generated)
├── data-model.md              # Phase 1 output (to be generated)
├── quickstart.md              # Phase 1 output (to be generated)
├── contracts/                 # Phase 1 output (WebSocket event contracts)
│   └── websocket-events.md
├── checklists/                # Quality validation checklists
│   └── requirements.md        # Specification validation checklist (completed)
└── tasks.md                   # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
apps/projector-app/
├── public/
│   └── index.html
├── src/
│   ├── components/
│   │   ├── phases/           # UI screens for each game phase
│   │   │   ├── ReadyForNextPhase.tsx
│   │   │   ├── AcceptingAnswersPhase.tsx
│   │   │   ├── ShowingDistributionPhase.tsx
│   │   │   ├── ShowingCorrectAnswerPhase.tsx
│   │   │   ├── ShowingResultsPhase.tsx
│   │   │   ├── AllRevivedPhase.tsx
│   │   │   └── AllIncorrectPhase.tsx
│   │   ├── ConnectionStatus.tsx
│   │   ├── ErrorScreen.tsx
│   │   └── LoadingIndicator.tsx
│   ├── hooks/
│   │   ├── useGameState.ts   # Firestore gameState/live listener
│   │   ├── useWebSocket.ts   # Socket-server connection + events
│   │   ├── useAnswerCount.ts # Dynamic questions/{id}/answers listener
│   │   └── useAudioEngine.ts # Audio pre-loading + playback management
│   ├── lib/
│   │   ├── firebase.ts       # Firebase SDK initialization
│   │   ├── audioManager.ts   # Web Audio API wrapper
│   │   └── config.ts         # Environment variable loading
│   ├── types/
│   │   └── index.ts          # Re-export from @allstars/types
│   ├── App.tsx               # Root component with phase router
│   ├── main.tsx              # Vite entry point
│   └── vite-env.d.ts
├── tests/
│   ├── unit/
│   │   ├── hooks/
│   │   └── lib/
│   ├── integration/
│   │   ├── firestore.test.ts
│   │   └── websocket.test.ts
│   └── e2e/
│       └── phase-transitions.spec.ts
├── .env.development          # Development environment config
├── .env.production.example   # Production template
├── package.json
├── tsconfig.json
├── vite.config.ts
├── vitest.config.ts
└── README.md
```

**Structure Decision**: Frontend web application structure with React components organized by game phase. The `/apps/projector-app/` directory follows the monorepo convention defined in the constitution. Shared types are consumed from `/packages/types/` as workspace dependencies. Audio management is encapsulated in a dedicated `audioManager.ts` module using Web Audio API. Testing is organized by scope (unit/integration/e2e) with Vitest for unit/integration and Playwright for E2E.

## Complexity Tracking

> No constitution violations requiring justification.

---

## Phase 0: Outline & Research

### Research Questions

1. **Vite + React + TypeScript setup for monorepo**
   - How to configure Vite within pnpm workspaces
   - TypeScript path aliases for `@/` imports
   - Hot Module Replacement (HMR) configuration

2. **Firebase SDK initialization patterns**
   - Best practices for Firestore emulator detection (localhost:8080)
   - Environment variable loading with Vite (`import.meta.env`)
   - Firebase Storage public URL patterns

3. **Web Audio API best practices**
   - Audio context initialization (user interaction requirement)
   - Pre-loading strategies for multiple assets
   - Crossfading implementation for BGM transitions
   - Audio layering without clipping

4. **Socket.io-client integration**
   - Automatic reconnection configuration (exponential backoff)
   - Event type safety with TypeScript
   - Connection status monitoring

5. **React hooks for real-time Firestore**
   - `onSnapshot` listener lifecycle management
   - Memory leak prevention (cleanup in useEffect)
   - Dynamic listener attachment/detachment patterns

6. **Countdown timer implementation**
   - Server timestamp vs local time handling
   - Sub-second precision with `requestAnimationFrame`
   - Timezone conversion for Firestore Timestamps

### Research Deliverables

Output: `research.md` with decisions, rationales, and code patterns for each question above.

---

## Phase 1: Design & Contracts

### Data Model

Extract entities from spec and document in `data-model.md`:

**Entities (consumed from `/packages/types/`)**:
- `GameState` - Live state document structure
- `Question` - Quiz question schema
- `GameResults` - Ranking data structure
- `Answer` - Submitted answer schema
- `WebSocketEvent` - Socket event payload types

**Local State Models**:
- `ConnectionStatus` - { firestore: boolean, websocket: boolean }
- `AudioAsset` - { id: string, url: string, type: 'bgm' | 'sfx', loaded: boolean }
- `PhaseConfig` - { phase: GamePhase, bgm: string[], sfx: string[] }

### Contracts

Generate WebSocket event contracts in `contracts/websocket-events.md`:

**Inbound Events** (from socket-server):
- `TRIGGER_GONG` - { timestamp: string }
- `SYNC_TIMER` - { deadline: string, serverTime: string }

**No Outbound Events** (projector-app is receive-only)

### Quickstart Guide

Create `quickstart.md` with:
1. Environment setup (pnpm install, Firebase emulator)
2. Development server startup (`pnpm dev`)
3. Audio asset upload instructions (Firebase Storage)
4. Testing gameState transitions via Firebase console
5. WebSocket event simulation for development

### Agent Context Update

Run `.specify/scripts/bash/update-agent-context.sh claude` to add:
- React 18.2 + TypeScript 5.3 + Vite 5.0
- Firebase SDK 10.x (Firestore + Storage)
- socket.io-client 4.x
- Web Audio API
- Vitest + React Testing Library + Playwright

---

## Re-check Constitution (Post-Design)

### I. Monorepo Architecture
✅ **PASS** - Structure aligns with `/apps/projector-app` convention
✅ **PASS** - Shared types dependency confirmed: `"@allstars/types": "workspace:*"`
✅ **PASS** - No boundary violations introduced

### II. Test-Driven Development (TDD)
✅ **PASS** - Test structure defined (unit/integration/e2e)
✅ **PASS** - TDD workflow preserved (tests before implementation)

### III. OpenAPI-First API Design
✅ **N/A** - Still frontend-only, no REST APIs exposed

### IV. Code Quality Gates
✅ **PASS** - ESLint/Prettier/Vitest configured in plan
✅ **PASS** - Quality gates enforceable

### V. Shell Command Safety
✅ **PASS** - No new shell command patterns introduced

**Final Gate Result**: ✅ ALL PASS - Ready for Phase 2 (Tasks)

---

## Next Steps

1. ✅ **Phase 0 Complete**: Generate `research.md` with technology decisions
2. ✅ **Phase 1 Complete**: Generate `data-model.md`, `contracts/websocket-events.md`, `quickstart.md`
3. **Phase 2**: Run `/speckit.tasks` to generate task breakdown in `tasks.md`
4. **Implementation**: Execute tasks following TDD discipline (Red-Green-Refactor)

**Command Complete**: `/speckit.plan` has finished Phase 0-1. Next command: `/speckit.tasks`
